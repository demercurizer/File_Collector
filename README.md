```markdown
# FileCollector

FileCollector – это эффективное решение для сборки файлов, передаваемых по сети чанками, которые могут приходить в произвольном порядке с возможными перекрытиями. Этот проект демонстрирует передовые подходы к параллельной обработке данных и оптимизации систем на C++.

## Описание

В проекте реализован потокобезопасный класс `FileCollector`, который обеспечивает эффективное восстановление файлов из чанков, передаваемых с информацией о позиции в файле. Основная задача – корректно собрать исходный файл даже в случае, когда полученные чанки пересекаются или поступают не по порядку. Решение гарантирует:
- **Потокобезопасность**: Изолированное обновление данных для каждого файла исключает гонки потоков.
- **Минимизацию копирования данных**: Эксплуатация move-семантики с использованием `std::vector<uint8_t>` позволяет значительно снизить накладные расходы при работе с размерными файлами.
- **Высокую производительность**: Продуманная архитектура минимизирует блокировки и эффективно обрабатывает пересекающиеся чанки.

## Архитектура и Стек Технологий

- **Язык программирования**: C++  
- **Сборка**: CMake  
- **Тестирование**: Unit-тесты с использованием [GTEST](https://github.com/google/googletest)  
- **Ключевые особенности**:
  - Структура данных для эффективной вставки и восстановления чанков.
  - Обработка ситуаций с пересекающимися чанками и дубликатами.
  - Оптимизация потокобезопасности при работе с параллельными потоками.

## Пример работы

Допустим, передается файл размером 10 байт, и приходят следующие чанки:
1. `OnNewChunk(fileId, 0, {A, B, C, D})` – первые 4 байта.
2. `OnNewChunk(fileId, 2, {C, D, E, F})` – пересекающийся чанк (начиная с pos = 2).
3. `OnNewChunk(fileId, 6, {G, H, I, J})` – не пересекающийся с предыдущими.

В итоге в памяти файл собирается следующим образом:  
`[A, B, C, D, E, F, G, H, I, J]`

## Использование

1. Инициализируйте сбор файла:
   ```cpp
   FileCollector collector;
   collector.CollectFile(fileId, fileSize);
   ```
2. При получении нового чанка:
   ```cpp
   collector.OnNewChunk(fileId, pos, std::move(chunk));
   ```
3. Получите собранный файл наиболее оптимальным способом, учитывая особенности проекта:
   ```cpp
   auto fileData = collector.GetFile(fileId);
   ```

## Тестирование

Проект включает unit-тесты, написанные с помощью Google Test. Рекомендуется запускать тесты для проверки корректности работы алгоритма даже в сложных сценариях с параллельной обработкой и перекрывающимися чанками.

## Сборка

Проект использует CMake для автоматизации сборки. Для сборки клонируйте репозиторий и выполните следующие команды:

```bash
mkdir build
cd build
cmake ..
make
```
